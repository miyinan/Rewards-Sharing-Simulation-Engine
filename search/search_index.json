{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rewards Sharing Simulation Engine for Ethereum- Documentation This is the documentation for the Rewards Sharing Simulation Engine for Ethereum. This project is forked from the University of Edinburgh's Blockchain Technology Lab, Reward Sharing Simulation Engine and extend to Ethereum. To know more about the original project, the source code is available on Github . Overview The simulation use Agent-Based-Modeling to models the behaviour of stakeholders in a Proof-of-Stake system, i.e. the way they use their stake to engage with the protocol depending on the rewards they expect to receive. It focuses particularly on the way different stakeholders combine their resources and create stake pools (it assumes an on-chain pooling mechanism like the one in Cardano) and follows the dynamics of the system until it (potentially) reaches an equilibrium. The implementation is based on the Ethereum blockchain. The simulation engine can be used to play out different scenarios and better understand the relationship between the system's input (e.g. parameters of the reward scheme or initial stake distribution) and its convergence properties (does it converge to an equilibrium and if yes how quickly, how decentralized is the final allocation of stake to the different stakeholders, and so on). For details on how to install the engine and run simulations, see the Setup page; for a complete guide on how to customize the simulation, see the Configuration page; for a description of the different output files that a simulation produces, see the Output page, and for examples to get started with and draw inspiration from, see the Examples page.","title":"Home"},{"location":"#rewards-sharing-simulation-engine-for-ethereum-documentation","text":"This is the documentation for the Rewards Sharing Simulation Engine for Ethereum. This project is forked from the University of Edinburgh's Blockchain Technology Lab, Reward Sharing Simulation Engine and extend to Ethereum. To know more about the original project, the source code is available on Github .","title":"Rewards Sharing Simulation Engine for Ethereum- Documentation"},{"location":"#overview","text":"The simulation use Agent-Based-Modeling to models the behaviour of stakeholders in a Proof-of-Stake system, i.e. the way they use their stake to engage with the protocol depending on the rewards they expect to receive. It focuses particularly on the way different stakeholders combine their resources and create stake pools (it assumes an on-chain pooling mechanism like the one in Cardano) and follows the dynamics of the system until it (potentially) reaches an equilibrium. The implementation is based on the Ethereum blockchain. The simulation engine can be used to play out different scenarios and better understand the relationship between the system's input (e.g. parameters of the reward scheme or initial stake distribution) and its convergence properties (does it converge to an equilibrium and if yes how quickly, how decentralized is the final allocation of stake to the different stakeholders, and so on). For details on how to install the engine and run simulations, see the Setup page; for a complete guide on how to customize the simulation, see the Configuration page; for a description of the different output files that a simulation produces, see the Output page, and for examples to get started with and draw inspiration from, see the Examples page.","title":"Overview"},{"location":"configuration/","text":"Configuration The simulation engine is highly configurable. From the reward scheme parameters to be used to the output files to be generated, there are numerous variables that can vary from execution to execution. This customization is performed using command-line arguments when running the main.py or batch-run.py scripts. We will go through all the available options here, but it's also possible to get an overview of the arguments and their default values by running the corresponding help commands: python main.py --help python batch-run.py --help Remember though that all arguments are optional, so it is not mandatory to manually set values for any of them. If not value is explicitly provided, then the corresponding default value is used. Command-line options These are all the arguments that can be configured during execution from the command line: --n : The number of stakeholders / agents in the simulation. The default value is 1000, but any natural numberis accepted. Note that the higher the value of n the slower the simulation becomes. --alpha : The min effective balance in simulation. In ethereum there is a min effective balance requirment, it is set to be 32 ETH. In our simulation we only look into porpotion, so min_effecive_balance = 1/n*alpha (reward sharing scheme parameter). The default value is 1, but any positive number is accepted. --beta : The max effective balance in simulation. In ethereum there is a max effective balance requirment, it is also set to be 32 ETH. max_effecive_balance = 1/n*beta (reward sharing scheme parameter). The default value is 2, but any positive number is accepted. beta must be bigger than alpha --agent_profile : There are two Ethstakeholder profile in our simulation, Easy and Hard. In Easy, agents can not choose the margin of their pool, and no limitations on opening pools. In hard, agents can choose the margin of their pool. --cost_min : The lowest initial cost that a stakeholder can have (acts as the lower bound of the Uniform distribution that cost values are drawn from). The default value is 10 <sup> -5 </sup> , but any non-negative real number is accepted. --cost_max : The highest initial cost that a stakeholder can have (acts as the upper bound of the Uniform distribution that cost values are drawn from). The default value is 10 <sup> -4 </sup> , but any non-negative real number > cost_min is accepted. extra_pool_cost_fraction : When an agent operates one pool, then the cost of the pool is equal to the cost of the agent. However, in our simulation it's possible for agents to operate multiple pools, so we assume that each additional pool an agent operates costs a fraction of their initial cost, and that fraction is the same for all agents and dictated by this argument. The default value is 0.4 (i.e. that a second pool costs 0.4 times as much as the first), but any non-negative real number is accepted (if we assume economies of scale then this value must be < 1, but if we assume some sort of Sybil cost then it can also be >= 1). --agent_activation_order : The order in which agents get activated. The default option is \"Semisimultaneous\" for activating a number of them simultaneously before moving on. --relative_utility_threshold : The relative utility threshold for accepting new moves (relates to inertia). If an agent develops a new strategy whose utility does not exceed that of its current one by at least this fraction, then the new strategy is rejected. The default value is 0, i.e. no relative utility threshold exists, but any non-negative real number is accepted. For example, if this threshold is 0.1 then it means that a new move has to yield utility at least 10% higher than that of the current move in order to be selected. --stake_distr_source : The distribution to use for the initial allocation of stake to the agents. The default choice is \"Pareto\", but other options include \"Flat\" for a distribution where all agents start with equal stake and \"File\" where a custom distribution is read from a csv file. In the latter case, the relevant file is expected to be at the root directory of the project, contain only stake values separated by commas and be named synthetic-stake-distribution-X-agents.csv where X is the number of agents used. --pareto_param : The parameter that determines the shape of the Pareto distribution that the stake is sampled from (only relevant if stake_distr_source is set to \"pareto\"). The default value is 2 but any positive real number is accepted. --inactive_stake_fraction : The fraction of the total stake of the system that remains inactive (is not allocated to any of the agents). The default value is 0, meaning that the active stake of the system is equal to the total stake, but any value between 0 and 1 is accepted. --inactive_stake_fraction_known : Flag that determines whether the fraction of the system's stake that is inactive is known upon the launch of the simulation (only relevant when there is inactive stake). If this fraction is known, then the simulation automatically adjusts the target number of pools k. The default setting is for it to remain unknown. --iterations_after_convergence : The minimum consecutive idle iterations that are required before the simulation declares convergence to an equilibrium and terminates. The default value is 10, but any natural number is accepted. --max_iterations : The maximum number of iterations that the simulation will perform before terminating. The default is 2000, but any natural number is accepted (it is recommended to keep this number high, in order to give the opportunity for simulations to converge to equilibria). --metrics : A list of ids that correspond to metrics that are tracked during the simulation. Default is [1, 2, 3, 4, 6, 17, 18, 24, 25]. For the full list of metrics and their corresponding identifiers, see the Metrics page. --generate_graphs : A flag that determines whether graphs relating to the tracked metrics are generated upon termination of the simulation. By default, this is activated. --seed : The seed to be used by the pseudorandom generator - can be specified to allow for reproducibility of the results. The default value is 'None', which means that a seed is chosen at random (can be accessed through the output of the simulation). Any non-negative integer can be accepted as the seed. --execution_id : An optional identifier for the specific execution of the simulation run, which is used for naming the output folder / files. If no identifier is provided, then one is generated automatically. --input_from_file : A flag that determines whether the input is read from a file (must be named \"args.json\" and be placed in the root directory of the project). If this is activated, then any other command line arguments are discarded. By default, this flag is not activated.","title":"Configuration"},{"location":"configuration/#configuration","text":"The simulation engine is highly configurable. From the reward scheme parameters to be used to the output files to be generated, there are numerous variables that can vary from execution to execution. This customization is performed using command-line arguments when running the main.py or batch-run.py scripts. We will go through all the available options here, but it's also possible to get an overview of the arguments and their default values by running the corresponding help commands: python main.py --help python batch-run.py --help Remember though that all arguments are optional, so it is not mandatory to manually set values for any of them. If not value is explicitly provided, then the corresponding default value is used.","title":"Configuration"},{"location":"configuration/#command-line-options","text":"These are all the arguments that can be configured during execution from the command line: --n : The number of stakeholders / agents in the simulation. The default value is 1000, but any natural numberis accepted. Note that the higher the value of n the slower the simulation becomes. --alpha : The min effective balance in simulation. In ethereum there is a min effective balance requirment, it is set to be 32 ETH. In our simulation we only look into porpotion, so min_effecive_balance = 1/n*alpha (reward sharing scheme parameter). The default value is 1, but any positive number is accepted. --beta : The max effective balance in simulation. In ethereum there is a max effective balance requirment, it is also set to be 32 ETH. max_effecive_balance = 1/n*beta (reward sharing scheme parameter). The default value is 2, but any positive number is accepted. beta must be bigger than alpha --agent_profile : There are two Ethstakeholder profile in our simulation, Easy and Hard. In Easy, agents can not choose the margin of their pool, and no limitations on opening pools. In hard, agents can choose the margin of their pool. --cost_min : The lowest initial cost that a stakeholder can have (acts as the lower bound of the Uniform distribution that cost values are drawn from). The default value is 10 <sup> -5 </sup> , but any non-negative real number is accepted. --cost_max : The highest initial cost that a stakeholder can have (acts as the upper bound of the Uniform distribution that cost values are drawn from). The default value is 10 <sup> -4 </sup> , but any non-negative real number > cost_min is accepted. extra_pool_cost_fraction : When an agent operates one pool, then the cost of the pool is equal to the cost of the agent. However, in our simulation it's possible for agents to operate multiple pools, so we assume that each additional pool an agent operates costs a fraction of their initial cost, and that fraction is the same for all agents and dictated by this argument. The default value is 0.4 (i.e. that a second pool costs 0.4 times as much as the first), but any non-negative real number is accepted (if we assume economies of scale then this value must be < 1, but if we assume some sort of Sybil cost then it can also be >= 1). --agent_activation_order : The order in which agents get activated. The default option is \"Semisimultaneous\" for activating a number of them simultaneously before moving on. --relative_utility_threshold : The relative utility threshold for accepting new moves (relates to inertia). If an agent develops a new strategy whose utility does not exceed that of its current one by at least this fraction, then the new strategy is rejected. The default value is 0, i.e. no relative utility threshold exists, but any non-negative real number is accepted. For example, if this threshold is 0.1 then it means that a new move has to yield utility at least 10% higher than that of the current move in order to be selected. --stake_distr_source : The distribution to use for the initial allocation of stake to the agents. The default choice is \"Pareto\", but other options include \"Flat\" for a distribution where all agents start with equal stake and \"File\" where a custom distribution is read from a csv file. In the latter case, the relevant file is expected to be at the root directory of the project, contain only stake values separated by commas and be named synthetic-stake-distribution-X-agents.csv where X is the number of agents used. --pareto_param : The parameter that determines the shape of the Pareto distribution that the stake is sampled from (only relevant if stake_distr_source is set to \"pareto\"). The default value is 2 but any positive real number is accepted. --inactive_stake_fraction : The fraction of the total stake of the system that remains inactive (is not allocated to any of the agents). The default value is 0, meaning that the active stake of the system is equal to the total stake, but any value between 0 and 1 is accepted. --inactive_stake_fraction_known : Flag that determines whether the fraction of the system's stake that is inactive is known upon the launch of the simulation (only relevant when there is inactive stake). If this fraction is known, then the simulation automatically adjusts the target number of pools k. The default setting is for it to remain unknown. --iterations_after_convergence : The minimum consecutive idle iterations that are required before the simulation declares convergence to an equilibrium and terminates. The default value is 10, but any natural number is accepted. --max_iterations : The maximum number of iterations that the simulation will perform before terminating. The default is 2000, but any natural number is accepted (it is recommended to keep this number high, in order to give the opportunity for simulations to converge to equilibria). --metrics : A list of ids that correspond to metrics that are tracked during the simulation. Default is [1, 2, 3, 4, 6, 17, 18, 24, 25]. For the full list of metrics and their corresponding identifiers, see the Metrics page. --generate_graphs : A flag that determines whether graphs relating to the tracked metrics are generated upon termination of the simulation. By default, this is activated. --seed : The seed to be used by the pseudorandom generator - can be specified to allow for reproducibility of the results. The default value is 'None', which means that a seed is chosen at random (can be accessed through the output of the simulation). Any non-negative integer can be accepted as the seed. --execution_id : An optional identifier for the specific execution of the simulation run, which is used for naming the output folder / files. If no identifier is provided, then one is generated automatically. --input_from_file : A flag that determines whether the input is read from a file (must be named \"args.json\" and be placed in the root directory of the project). If this is activated, then any other command line arguments are discarded. By default, this flag is not activated.","title":"Command-line options"},{"location":"metrics/","text":"Metrics There are several metrics, or model reporters, that can be tracked during a simulation. Each of them is associated with an id for convenience. We provide details for all of them below. Stake All the value should be below 1. Total initial stake is uniformed ito 1. In each round, the sum of all stake owned by agents in this simulation is 1. Total pledge: id=1 the total pledge stake of the system, by summing of all pools' pldege Mean pledge : id=2 the average value of stake that is pledged in pools. Median pledge : id=3 the median value of stake that is pledged in pools. Pledge rate: id=4 the fraction of active stake that is used as pledge (total pledge / total active stake). Total delegated stake id=5 the sum of all delegated assets. If all pools are solo/private, then total_delegated_stake=0. total_delegated_stake=sum(pool.stake-pool.pledge) Total pool stake: id=6 the sum of all used stake: delegation+ pledge. Liquid pool insurance not included. Total insurance stake: id=7 the sume of all used stake as insurance. when a operator want to open a liquidity pool, they need certain amount of stake as insurance. This will generate liquidity gain. Operator Only investigate into operator, doesn't take delegator agents into account. For example. average pools per operator will alwasy be positive Operator count: id=8, the number of unique stakeholders that operate pools. If a operator operates two pools, it won't count it twice Average pools per operator : id=9 the average number of pools that an operator controls. Max pools per operator : id=10 the maximum number of pools that an operator controls. Median pools per operator : id=11 the median number of pools that an operator controls. Cost efficient stakeholders : id=12 the number of agents for whom it is possible to make profit by operating a pool. There reward is bigger than cost. Decentralization Nakamoto coefficient : id=13 the minimum number of entities that collectively control more than 50% of the system's active stake through their pools. Statistical distance: id=14 the statistical distance of the distributions of the stake that agents controlled at the beginning of the simulation vs on this round. reflects the extent of change in stake distribution and can be used to analyze the impact of the process on agent behavior and decision-making. To note that in this simulation reward don't conpond with each round, so their stake will not change. The meaning Controlled stake means stake in opertaor's pool. For example, a agent owns 2 pools, then stake under controlled will be the sum of two pools's stake. Doesn't take agent's own stake into account. Min-aggregate pledge : id=15 the minimum aggregate pledge of pools that collectively control more than 50% of the system's active stake. Note that the calculation of this metric is slow because of the complexity of the problem. This metrix is useful in cardano, but not in ethereum, because liquid pools can not choose their pledge. Pool homogeneity factor : id =16 A metric that describes how homogeneous the pools of the system are (the highest possible value is 1, which is given when all pools have the same size). so max_stake in pool list will also be average_stake in pool list, ideal area = pool_count*max_stake , actual area = sum( pool stake ) homogeneity_factor= actual_area/ideal_area HHI agent: id=17 The Herfindahl-Hirschman Index (HHI) is a metric used to measure market concentration or industry concentration. It provides insights into the distribution of firm sizes within a market, offering information about market competition and economic concentration. We consider each agent as one firm. In a simulation of n agents, the value is between [1/n,1] Lower HHI values indicate a more decentralized and competitive market (1/n)^2*n=1/n , while higher HHI values suggest greater market concentration and dominance by a few large firms 1^2**1+0^2*(n-1)=1 . agent_controlled_stake_share=agent_controlled stake/total_pool_stake HHI_agent= sum(agent_controlled_stake_share**2) Gini agent coefficient: id=18 a variation of the gini coefficient, where we consider each agent as an individual and each pool as a \u201ccoin\u201d. Then the gini-agent is the gini coefficient considering each indiviual with the pools they have. In case of each agent operating one pool this coefficient is 0. 100% agents control 100%pools, 5% agents control 5% pools Gini agent stake coefficient: id=19 like the gini agent coefficient above, it is the gini coefficient of each agents with the total stake each agent controls through their pools instead of the number of pools they operate. Other Pool count: id=20 the number of active pools in the system. Including Liquid Pools and Solo Pool Mean margin: id= 21 the average profit margin across all active pools. Median margin: id= 22 the median profit margin across all active pools. Total Liquidity Gain : id=23 is the liquidity gain by using liquidity staking protocols, it comes from operator's insurance and delegator's delegation. total_liquidity_gain = total_liquidity_reward/TOTAL_REWARD_PER_EPOCH it should always be smaller than TOTAL_REWARD_PER_EPOCH/liquidity_factor Total cost: id=24 the sum of cost of all pools in this simulation. sum(pool.cost) Iterations : id =25 the number of iterations that the simulation has gone through. Refer to the Configuration page for details on specifying which metrics will be used during a simulation.","title":"Metrics"},{"location":"metrics/#metrics","text":"There are several metrics, or model reporters, that can be tracked during a simulation. Each of them is associated with an id for convenience. We provide details for all of them below.","title":"Metrics"},{"location":"metrics/#stake","text":"All the value should be below 1. Total initial stake is uniformed ito 1. In each round, the sum of all stake owned by agents in this simulation is 1. Total pledge: id=1 the total pledge stake of the system, by summing of all pools' pldege Mean pledge : id=2 the average value of stake that is pledged in pools. Median pledge : id=3 the median value of stake that is pledged in pools. Pledge rate: id=4 the fraction of active stake that is used as pledge (total pledge / total active stake). Total delegated stake id=5 the sum of all delegated assets. If all pools are solo/private, then total_delegated_stake=0. total_delegated_stake=sum(pool.stake-pool.pledge) Total pool stake: id=6 the sum of all used stake: delegation+ pledge. Liquid pool insurance not included. Total insurance stake: id=7 the sume of all used stake as insurance. when a operator want to open a liquidity pool, they need certain amount of stake as insurance. This will generate liquidity gain.","title":"Stake"},{"location":"metrics/#operator","text":"Only investigate into operator, doesn't take delegator agents into account. For example. average pools per operator will alwasy be positive Operator count: id=8, the number of unique stakeholders that operate pools. If a operator operates two pools, it won't count it twice Average pools per operator : id=9 the average number of pools that an operator controls. Max pools per operator : id=10 the maximum number of pools that an operator controls. Median pools per operator : id=11 the median number of pools that an operator controls. Cost efficient stakeholders : id=12 the number of agents for whom it is possible to make profit by operating a pool. There reward is bigger than cost.","title":"Operator"},{"location":"metrics/#decentralization","text":"Nakamoto coefficient : id=13 the minimum number of entities that collectively control more than 50% of the system's active stake through their pools. Statistical distance: id=14 the statistical distance of the distributions of the stake that agents controlled at the beginning of the simulation vs on this round. reflects the extent of change in stake distribution and can be used to analyze the impact of the process on agent behavior and decision-making. To note that in this simulation reward don't conpond with each round, so their stake will not change. The meaning Controlled stake means stake in opertaor's pool. For example, a agent owns 2 pools, then stake under controlled will be the sum of two pools's stake. Doesn't take agent's own stake into account. Min-aggregate pledge : id=15 the minimum aggregate pledge of pools that collectively control more than 50% of the system's active stake. Note that the calculation of this metric is slow because of the complexity of the problem. This metrix is useful in cardano, but not in ethereum, because liquid pools can not choose their pledge. Pool homogeneity factor : id =16 A metric that describes how homogeneous the pools of the system are (the highest possible value is 1, which is given when all pools have the same size). so max_stake in pool list will also be average_stake in pool list, ideal area = pool_count*max_stake , actual area = sum( pool stake ) homogeneity_factor= actual_area/ideal_area HHI agent: id=17 The Herfindahl-Hirschman Index (HHI) is a metric used to measure market concentration or industry concentration. It provides insights into the distribution of firm sizes within a market, offering information about market competition and economic concentration. We consider each agent as one firm. In a simulation of n agents, the value is between [1/n,1] Lower HHI values indicate a more decentralized and competitive market (1/n)^2*n=1/n , while higher HHI values suggest greater market concentration and dominance by a few large firms 1^2**1+0^2*(n-1)=1 . agent_controlled_stake_share=agent_controlled stake/total_pool_stake HHI_agent= sum(agent_controlled_stake_share**2) Gini agent coefficient: id=18 a variation of the gini coefficient, where we consider each agent as an individual and each pool as a \u201ccoin\u201d. Then the gini-agent is the gini coefficient considering each indiviual with the pools they have. In case of each agent operating one pool this coefficient is 0. 100% agents control 100%pools, 5% agents control 5% pools Gini agent stake coefficient: id=19 like the gini agent coefficient above, it is the gini coefficient of each agents with the total stake each agent controls through their pools instead of the number of pools they operate.","title":"Decentralization"},{"location":"metrics/#other","text":"Pool count: id=20 the number of active pools in the system. Including Liquid Pools and Solo Pool Mean margin: id= 21 the average profit margin across all active pools. Median margin: id= 22 the median profit margin across all active pools. Total Liquidity Gain : id=23 is the liquidity gain by using liquidity staking protocols, it comes from operator's insurance and delegator's delegation. total_liquidity_gain = total_liquidity_reward/TOTAL_REWARD_PER_EPOCH it should always be smaller than TOTAL_REWARD_PER_EPOCH/liquidity_factor Total cost: id=24 the sum of cost of all pools in this simulation. sum(pool.cost) Iterations : id =25 the number of iterations that the simulation has gone through. Refer to the Configuration page for details on specifying which metrics will be used during a simulation.","title":"Other"}]}